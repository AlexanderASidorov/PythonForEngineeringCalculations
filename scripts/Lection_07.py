# -*- coding: utf-8 -*-
"""
Created on Thu Sep 15 13:26:57 2022

@author: sidorow
"""

#  Библиотека NumPy
#
#
#
#
"""
Библиотека NumPy (Numeric Python) - основная причина, по которой Python
стал одним из самых популярных языков программирования алгоритмов машинного
обучения.
Почему вообще возникла и получила широкое распространение библиотека NumPy?
Допустим у нас есть список значений  и нам по каким-то причинам нужно все 
значения из этого списка увеличить на 10%
"""
x= [355.0, 469.87, 584.75, 699.63, 814.50, 929.38, 1044.26, 1159.13, 1274.01, 
    1388.89, 1503.76]
# Если мы просто умножим переменную x на 1.1, то получится следующее:
#x=x*1.1
# Как видите, в консоли появилось сообщение об ошибке:
# can't multiply sequence by non-int of type 'float'
#%% Т.е. для того, что бы все числа из этого списка увеличить на 10% нам 
# необходимо запустить цикл:

x_10 = [item*1.1 for item in x ]
# или, что бы числа в списке были более компактными:
x_10 = [round(item*1.1, 2) for item in x ]


#%% или то же самое можно сделать по-другому:
x_10=list() # создаем пустой список
j=-1 # создаем переменную для запуска счетчика
while j<(len(x)-1): ## нам нужно, что бы на самой последней итерации
# значение j было равно значению индекса последнего числа в списке x,
# т.е. 11
    j=j+1
    x_10.append(round(x[j]*1.1, 2))
#%%
"""
Приведенные выше два способа в общем простые, но все же удобнее было бы,
умножать весь список на число, как это реализовано, например в MatLab.
Самая главная проблема использования циклов, что в некомпелируемых языках
программирования циклы довольно медленно работают и их рекомендуется избегать
если есть такая возможность.
Для решения этой проблемы в Python был придуман самостоятельный тип данных
NumPy aarray.
Что бы им воспользоваться нам необходимо импортировать библиотеку NumPy. Она 
предустановлена в большинстве сред разработки для Python
"""
import numpy as np # здесь np - общепринятое сокращение для вызова компонентов
# этой библиотеки
# после этого мы можем создавать массивы типа numpy array
FirsNumPyArray = np.array([1, 2, 13, 3, 12, 45, 99, 1000, 11, 56]) # массив целочисленных значений
SecondNumPyArray = np.array([1, 2, 12, 3.14]) # массив значений типа float
ThirdNumPyArray = np.array([[1, 3.14, 3], [4, 5, 4]]) # двумерный массив

# Можно преобразовать имеющиеся списки в массивы NumPy:
FourthNumPyArray=np.array([x, x_10])
# Если нам нужен массив не 2 на 11, а 11 на 2, то его можно транспанировать:
FifthNumPyArray=np.array([x, x_10]).transpose()
"""
все 5 массивов, которые мы создали выше имеют два основных ограничения:
 1. они имеют фиксированный размер, т.к. мы не можем добавлять в них строки
или колонки с помощью команд pop или append
 2. все элементы массива NumPy имеют один и тот же тип, т.е. не может быть
что часть массива integer, а часть float
Важным и часто используемым инструментом является комманда np.zeros([n, m]). 
Т.е. мы создаем массив NumPy состоящий из нулей, который потом можем заполнить 
нужными нам значениями 
"""
SixthNumPyArray = np.zeros([11, 2])
# Аналогично можно построить массив, состоящий из единиц:
SeventhNumPyArray=np.ones([2, 11])
# Иногла нужно бывает создать массив, например от n до m с шагом delta:
m=2.5
n=12
delta=0.5
EighthNumPyArray=np.arange(m,n,delta)
# Можно наоборот от n до m с отрицательным шагом delta
NinethNumPyArray=np.arange(n, m, -delta)
# а можно расстояние от m до n разбить на нужное количество отрезков:
TenthNumPyArran=np.linspace(m, n, 100)
# Возвращаясь к исходной задаче, где нам необходимо было увеличить все значения
# из списка x на 10%, с помощью библиотеки NumPy это можно сделать
# следующим образом:
# Конвертируем список x в массив NumPy
x_NumPyArray=np.array(x)
# И теперь мы можем просто умножить получившийся массив на 1.1 и все его элементы
# в результате увеличатся на 10%
x_10_NumPyArray=x_NumPyArray*1.1
# По такому же принципу мы можем осуществлять действия над элементами двух
# масссивов, например почленно сложить значения:
Summ_x_x_10_NumPyArray=x_NumPyArray+x_10_NumPyArray
# Можем, например, извлечь квадратный корень из каждого элемента
Sqrt_Summ_x_x_10_NumPyArray=np.sqrt(Summ_x_x_10_NumPyArray) 
# Изложенный выше подход называют ВЕКТОРИЗАЦИЕЙ.
#
#
# Индексация в массивах NumPy происходит аналогично индексации в списках:
Maximum_x=FifthNumPyArray[10,1]
# При необходимости мы можем поменять тот или иной член массива:
FifthNumPyArray[10,1]=FifthNumPyArray[10,1]*1.1
# а если нужно, например, обнулить массив, то необходимо указать все элементы 
# массива
FifthNumPyArray[:]=0
# Можно изменить размер массиы:
FirsNumPyArray = FirsNumPyArray.reshape(5, 2)
###
'''
Одним из ключевых, на мой взгляд, инструментом библиотеки NumPy является
модуль линейной алгебры. Более подробно мы изучим его на следующем занятии,
сегодня давайте попробуем решить СЛАУ вида:
    
    7x+4y−z=9
    −5x+8y+3z=15
    3x+2y−12z=35

'''
# обозначим коэффициенты этого уравнения как матрицу A:
    
A = np.array([[7, 4, -1], [-5, 8, 3], [3, 2, -12]])

# а свободные коэффициенты через вектор b
B = np.array([9, 15, 35])

# известно, что решением этой системы будет:
#  X = A**(-1) * B
# где X это x, y и z, A**(-1) - матрица, обратная A
#
# обратная матрица в NumPy расчитывается командой np.linalg.inv(A)
# итого получим решение:
#
X_01 = np.linalg.inv(A)@B
# обратите внимание, что умножение матрицы на вектор происходит с помощью
# знака @
# проыерим решение:
B_= np.array([A[i, :]@X_01 for i in range (np.shape(A)[0])])
# то же самое можно было получить следующим образом:
X_02=np.linalg.solve(A, B)
# а можно с помощью метода наименьших квадратов (но это лишне для нашего СЛАУ):
X_03 = np.linalg.lstsq(A, B)

    
    
    
    





























