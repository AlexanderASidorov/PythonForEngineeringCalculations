#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np


"""
SciPy – это библиотека модулей языка Python для научных расчетов, кото-
рая предоставляет более специализированные функциональные возможно-
сти, чем общие структуры данных и математические алгоритмы библиотеки
NumPy.
Документация https://docs.scipy.org/doc/scipy/tutorial/index.html#user-guide



Задача #1. Решение СЛАУ

Одним из ключевых, на мой взгляд, инструментом библиотеки NumPy является
модуль линейной алгебры. Давайте попробуем решить СЛАУ вида:
    
    7x+4y−z=9
    −5x+8y+3z=15
    3x+2y−12z=35
    
(см. лекцию #7)    

"""
# обозначим коэффициенты этого уравнения как матрицу A:
    
A = np.array([[7, 4, -1], [-5, 8, 3], [3, 2, -12]])

# а свободные коэффициенты через вектор b
B = np.array([9, 15, 35])

X_01=np.linalg.solve(A, B)

# то же самое можно сделать с помоьщью библиотеки SciPy
# (scipy.linalg это фактически копия np.linalg, т.е. разницы в решении быть
# быть не должно)

from scipy.linalg import solve
X_02 = solve(A, B)

#%%
"""
Задача #2. Решение СНЛАУ
На примере решения системы уравнений Аврами
https://ru.wikipedia.org/wiki/Уравнение_Джонсона_—_Мела_—_Аврами_—_Колмогорова

0.99 = 1 - exp(-1/b*(t099**n))
0.5 = 1 - exp(-1/b*(t05**n))

здесь:
        t099 - время, необходимое на переход 99% объема материала из 
                материнской фазы в дочернюю
        t05 - время, необходимое на переход 50% объема материала из 
                материнской фазы в дочернюю
                
        b, n - неизвестные
                

Уравнение Аврами широко используется во многих науках для расчета фазовых
превращений.


Т.е. задача сводится к тому, что нужно найти коэффициенты b и n по известным 
значениям времени t099 и t001.

Примим t099 = 98.2 секунд
       t001 = 54.1  секунд

Т.е. уравнение, которое нужно решить выглядит следующим образом:
    0.99 = 1 - exp(-1/b*(98.2**n))
    0.5 = 1 - exp(-1/b*(54.1**n))
    
или
    0 = 0.01 - exp(-1/b*(98.2**n))
    0 = 0.5 - exp(-1/b*(54.1**n))

Его можно решить аналитически, но мы попробуем для начала сделать это
численно, с момщью модуля scipy.optimize
"""
from scipy.optimize import fsolve
import numpy as np
import matplotlib.pyplot as plt

def avrami_system (x):
    '''
    Система из двух уравненией Аврами при различном времени выдержки в 
    изотермических условиях

    Parameters
    ----------
    x : NumPy array, коэффициенты b и n.

    Returns
    -------
    Если коэффициенты подобраны правильно, то функция должна возвращать список
    из двух нулей или близкие им значения

    '''
       
    b = x[0]
    n = x[1]
             
    return [0.01 - np.exp((-1/b)*(98.2**n)),
            0.5 - np.exp((-1/b)*(54.1**n))]
    
root = fsolve(avrami_system, [1.0, 1.0])


# можем проверить результат. avrami_system(root) долна быть около 0.0
zeros = avrami_system(root)
check_result = np.isclose(avrami_system(root), [0.0, 0.0])

# Давайте визуализируем результат
# Напишем каноническую функцию для уравениня Аврами

def avrami(t, b, n):
    '''
    Уравение Аврами

    Parameters
    ----------
    t : float, время изотермической выдержки;
    b : float, коэффициент b;
    n : float, коэффициент n;

    Returns
    -------
    fraction : float в пределах от 0 до 1. Объемная доля дочерней фазы. 

    '''
      
    fraction = 1 - np.exp((-1/b)*(t**n))
    
    return fraction

# создадим массив значенией времени

time = np.linspace(0, 110)

# и расчитаем для каждого значения времени объемную долю
fraction = avrami(time, root[0], root[1]) 



# Создадим объект fig01 и настроем его размер и разрешение    
fig01 = plt.figure()
fig01.set_size_inches(8.0, 5.0)
fig01.set_dpi(600)

# отображаем кривую время - объемная доля
plt.plot(time, fraction)
# отображаем две исходные точки, на основе которых мы решали уравнение
plt.plot([54.1, 98.2], [0.5, 0.99], 'o')
# отобразим на графике сетку
plt.grid()
# обозначим ось x и y
plt.xlabel('Время, с')
plt.ylabel('Объемная доля')


#%%

"""
Задача #3. Подбор коэффициентов.
Допустим у нас есть то же уравнение Аврами
f = 1 - exp(-1/b*(t**n))
но на этот раз нам известно значение функции в некоторых точках:

    f = 0.1, t = 27.2
    f = 0.2, t = 35.4
    f = 0.5, t = 54.2
    f = 0.8, t = 71.3
    f = 0.9, t = 82.2
    
Допустим это результат каких-то экспериментальных исследований, поэтому данные
имеют некотрые "шумы", которые мы в рамках нашей задачи смоделируем с помощью
генератора случайных чисел.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit


# исходные данные
f_initial = np.array([0.1, 0.2, 0.5, 0.8, 0.9])
t_initial = np.array([27.2, 35.4, 54.2, 71.3, 82.2])


# объединим данные в единый массив:
initial_data = np.array([t_initial, f_initial]).transpose()
# здесь первый столбец - время
# второй столбец - объемная доля

# добавляем шумы...

# создадим два пустых списка, куда далее будем записывать сгенерированные 
# значения    
f = []
t = []

# количество дополнительных точек вокруг каждой точки исходных данных
noize = 10

# с помощью переменной i мы итерируем через массив с исходными данными
for i in range (initial_data.shape[0]):
    # добавляем в списки для сгенерированных значений исходные значения
    t.append(initial_data[i,0])
    f.append(initial_data[i,1])
    
    j = 0 # переменная j отвечает за количество сгенерированных точек вокруг
            # i-й точки исходных данных. Ее мы будем в цикле сравнивать
            # с переменной noize
    while j <= noize:
        # Для каждой j-й точки с помощью генератора случайных чисел
        # назначаем отклонение по времени 
        deviation = np.random.randint(-10,10)/100
        t.append(initial_data[i,0] + initial_data[i,0]*deviation)
        
        # Для каждой j-й точки с помощью генератора случайных чисел
        # назначаем отклонение по объемной доле дочерней фазы
        deviation = np.random.randint(-10,10)/100
        #deviation = np.array([-0.08, 0.08])
        #deviation = np.random.choice(deviation)
        f.append(initial_data[i,1] + deviation)
        # увеличиваем j на 1 (если она еще не равна переменной noize)
        j += 1

# сконвертируем оба списка в NumPy array
f = np.array(f)
t = np.array(t)




# Создадим объект fig02 и настроем его размер и разрешение    
fig02 = plt.figure()
fig02.set_size_inches(8.0, 5.0)
fig02.set_dpi(600)

# отобразим на графице исходные точки
plt.scatter(t_initial, f_initial, marker = 'o')
# и точки, которые мы сгенерировали
plt.scatter (t, f, marker = '.')

# отобразим на графике сетку
plt.grid()
# обозначим ось x и y
plt.xlabel('Время, с')
plt.ylabel('Объемная доля')

def avrami(t, b, n):
    '''
    Комментраий к функции см. выше, в предыдущей ячейке

    '''
    
    
    fraction = 1 - np.exp((-1/b)*(t**n))
    
    return fraction


# Решение:
# для нахождения коэффициентов b и n в данном случае мы будем использовать 
# метод curve_fit библиотеки scipy.
# можно попробовать сделать это "в лоб", с настройками по-умолчанию:

#popt, pcov = curve_fit(avrami, t, f)

# но с высокой вероятностью у нас ничего не получится

# Обччно для решения подобной задачи необходимо задаться начальными значениями
# неизвестных и пределами их варьирования:

# начальное значение    
initial_guess = [1000, 3]

# пределы варьирования. важно, что первая скобка это нижний предел, а вторая
# - верхний
bnds = ((0, 1), (np.inf, 4))

popt, pcov = curve_fit(avrami, t, f, p0 = initial_guess, bounds = bnds, method = 'dogbox')
b = popt[0]
n = popt[1]

# Переменная pcov служит для оценки ошибки полученных коэфициентов.
# Подробности вы можете посмотреть в этом видео:
# https://www.youtube.com/watch?v=HNBve6KtwmA
# В рамках данного курса мы решение проверим визуально, с помощью графика:




# создадим массив значенией времени
time = np.linspace(0, 110)
# и расчитаем для каждого значения времени объемную долю
fraction = avrami(time, b, n) 



# Создадим объект fig03 и настроем его размер и разрешение    
fig03 = plt.figure()
fig03.set_size_inches(8.0, 5.0)
fig03.set_dpi(600)

plt.scatter(t_initial, f_initial, marker = 'o')
plt.scatter (t, f, marker = '.')
plt.plot(time, fraction)

plt.grid()
plt.xlabel('Время, с')
plt.ylabel('Объемная доля')


#%%

"""
Задача #4. Интерполяция данных.
Допустим у нас есть те же данные:

    f = 0.1, t = 27.2
    f = 0.2, t = 35.4
    f = 0.5, t = 54.2
    f = 0.8, t = 71.3
    f = 0.9, t = 82.2
 
Но в этот раз мы не знаем уравнениt, которое описывает характер распределения данных.
В этом случае мы можем использовать функцию интерполяции:
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d


# снова сгенерируем нужные нам данные


# исходные данные
f_initial = np.array([0.1, 0.2, 0.5, 0.8, 0.9])
t_initial = np.array([27.2, 35.4, 54.2, 71.3, 82.2])




# Есть разные методы интерполяции, давайте посмотрим разницу
f_nearest = interp1d(t_initial, f_initial, kind='nearest')
f_linear  = interp1d(t_initial, f_initial)
f_cubic   = interp1d(t_initial, f_initial, kind='cubic')

# для визуализации результатов мы создадим новый массив для t
t_ = np.linspace(np.min(t_initial), np.max(t_initial), 100)


# Создадим объект fig04 и настроем его размер и разрешение    
fig04 = plt.figure()
fig04.set_size_inches(8.0, 5.0)
fig04.set_dpi(600)

# отобразим на графице исходные точки
plt.scatter(t_initial, f_initial, marker = 'o', label = 'исходные точки')
# и результаты интерполяции
plt.plot(t_, f_nearest(t_), label='nearest')
plt.plot(t_, f_linear(t_), label='linear')
plt.plot(t_, f_cubic(t_), label='cubic')

plt.grid()
plt.legend()
plt.xlabel('Время, с')
plt.ylabel('Объемная доля')


