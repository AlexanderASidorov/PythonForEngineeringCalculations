# -*- coding: utf-8 -*-
#
# Библиотека NumPy (продолжение лекции #8). Кластеризация данных.

import numpy as np
import matplotlib.pyplot as plt

'''
Допустим у нас есть выборка из какого-то количества людей и ам известны
рост и вес каждого человека. Допустим нам нужно определить к какой группе
относится человек согласно индекса массы его тела.
Подробнее об индексе массы тела:
    https://ru.wikipedia.org/wiki/Индекс_массы_тела


'''



# Для создания искусственной выборки воспользуемся генератором случайных
# чисел понятием медианный вес и медианный индекс массы тела
# медианный вес человека в выборке
weight_avrg = 90.0

# медианный индекс массы тела человека
mass_index_avrg = 28.0
# возможный разброс по индексу массы тела человека
mass_index_delta = 12

high_avrg = 1.75



## количество людей в выборке
n_people = 1000

# сгенерируем данные о росте человека
hight = np.random.normal (high_avrg, 0.1, n_people)
print(f' самый высокий человек в выборке - {np.max(hight)}')
print(f' самый низкий человек в выборке - {np.min(hight)}')
print(f' средний рост людей в выборке - {np.mean(hight)}')

# сгенерируем данные об индексе массы тела
mass_index = mass_index_avrg + np.random.uniform(-1, 1, n_people)*mass_index_delta
# на основе массы тела и индекса тела расчитаем массу каждого человека
weight = mass_index*(hight)**2
print(f' самый грузный человек в выборке - {np.max(weight)}')
print(f' самый легкий человек в выборке - {np.min(weight)}')
print(f' средний вес людей в выборке - {np.mean(weight)}')


# Выводим результаты на графики
# строим график состоящий и 4 отдельных ячеек: 2 колонки и 2 столбца
fig01, ax = plt.subplots(nrows=3, ncols=1, sharex=False)
# устанавливаем размер картинки
fig01.set_size_inches(9.0, 12.0)
# ее разрешение
fig01.set_dpi(900)
plt.subplots_adjust(left=None,
                    bottom=None, 
                    right=None, 
                    top=None, 
                    wspace=None, 
                    hspace=0.5)




# строим график рост человека от его массы
ax[0].plot(weight, hight, 'ko', markerfacecolor='w')
ax[0].set_ylabel('Рост человека, м')
ax[0].set_xlabel('Масса человека, кг')
ax[0].set_title('Рост и масса тела человека в выбррке из ' + str(n_people) + ' человек' )

# строим график рост человека от его индекса массы тела
ax[1].plot(mass_index, hight, 'ko', markerfacecolor='w')
ax[1].set_ylabel('Рост человека, м')
ax[1].set_xlabel('Индекс массы тела')
ax[1].set_title('Рост и индекс массы тела человека в выбррке из ' + str(n_people) + ' человек' )

# строим график индекс массы тела человека от его массы тела
ax[2].plot(weight, mass_index, 'ko', markerfacecolor='w')
ax[2].set_ylabel('Индекс массы тела человека')
ax[2].set_xlabel('Масса человека, кг')
ax[2].set_title('Индекс массы тела человека и его масса в выбррке из ' + str(n_people) + ' человек' )

# объединим рост и вес в один массив с двумя столбцами
data = np.array([weight, hight]).transpose()

# пусть количетсво кластеров будет равно 3
k = 7
# количество итераций класстаризации - тоже 3
iteri = 70

for _ in range(iteri):
    # выберем первый центр каждого из трех кластеров
    ridx = np.random.choice(range(len(data)), k, replace=False)
    centroids = data[ridx,:]
    # сортируем эти точки по массе от меньшей к большей
    centroids=centroids[centroids[:,0].argsort()]
   


    # далее мы будем измерять рассточние от каждой из точек до центроида.
    # для этого создадим переменную dist: количество строк - количество точек,
    # количество столбцов - количество кластеров
    dists = np.zeros((data.shape[0], k))
    for i in range(k):
        dists[:,i] = np.sum(((data-centroids[i,:])**2)**0.5, axis=1)

    # определяем к какой группе относится человек 
    groupidx = np.argmin(dists, axis=1)

    # пересчитываем центроид
    for j in range(k):
        centroids[j,:] = [ np.mean(data[groupidx==j,0]), np.mean(data[groupidx==j,1]) ]
        
        
# Выводим результаты на графики
# строим график состоящий и 4 отдельных ячеек: 2 колонки и 2 столбца
fig02, ax = plt.subplots(nrows=2, ncols=1, sharex=True)
# устанавливаем размер картинки
fig02.set_size_inches(12.0, 9.0)
# ее разрешение
fig02.set_dpi(900)
plt.subplots_adjust(left=None,
                    bottom=None, 
                    right=None, 
                    top=None, 
                    wspace=None, 
                    hspace=0.2)


# строим график рост человека от его массы
ax[0].plot(weight, hight, 'ko', markerfacecolor='w')
ax[0].set_ylabel('Рост человека, м')
ax[0].set_title('Рост и масса тела человека в выбррке из ' + str(n_people) + ' человек' )

# строим график рост человека от его массы
colours = [ "red", "blue", "green", "yellow", "purple", "orange", "grey" ]
labels = ['Дифицит', 'Недостаток', 'Норма', 'Избыток', 'Степень 1', 'Степень 2', 'Степень 3']


for i in range (k):
    ax[1].plot(data[groupidx==i][:, 0], data[groupidx==i][:, 1],'ko', markerfacecolor=colours[i], label = labels[i])
    
ax[1].plot(centroids[:, 0], centroids[:, 1], 'kX')
ax[1].set_ylabel('Рост человека, м')
ax[1].set_xlabel('Масса человека, кг')
ax[1].set_title('Рост и масса тела человека в выбррке из ' + str(n_people) + ' человек' )
ax[1].legend(loc="upper left")
#%%%
import numpy as np
'''
Матрица – это вектор, перенесенный на следующий уровень. Матрицы как
математические объекты очень разноплановы. В них могут храниться наборы чисел, 
уравнений, геометрические преобразования, положения частиц во времени, 
финансовые отчеты и огромадное число других вещей.
В зависимости от контекста матрицы концептуализируются в уме как множество 
векторов-столбцов, расположенных бок о бок.
'''

# неквадратная матрица
matrix01= np.array([[0.1, 0.3, 1.2],
                   [2.1, 0.2, 1.0],
                   [0.7, 2.1, 0.4],
                   [1.2, 2.2, 0.9]])


# Квадратная матрица случайных чисел
matrix02 = np.random.randn(5, 5)

# Диаганаль матрицы
diagonal_01_01 = np.diag(matrix01, k=0)
diagonal_01_02 = np.diag(matrix01, k=-1)

# Извлечение верхнего треугольника
triangl_01_upper = np.triu(matrix02, k=0)
triangl_01_lower = np.tril(matrix02, k=0)

'''
Единичная матрица является одной из наиболее важных специальных
матриц. Она эквивалентна числу 1 в том смысле, что любая матрица или
вектор, умноженные на единичную матрицу, будут той же самой матрицей
или вектором. 
Единичная матрица – это квадратная диагональная матрица, все диагональные 
элементы которой имеют значение 1. Она обозначается буквой I. 
'''

I5 = np.eye(5, k=0)
I6=np.eye(6, k=1) # диагональ можно, при необходимости сместить

# Матрица нулей и единиц
zeros = np.zeros([5, 3])
ones = np.ones([5, 3])
# Матрица заполненная каким-то числом
nines = np.full([5, 3], 9.0)

'''
Сложение и вычитание матриц:
Две матрицы складываются путем сложения соответствующих элементов
матриц.
'''
matrix_01 = np.array([[1, 2],
                      [3, 4]])

matrix_02 = np.array([[5, 6],
                      [7, 8]])

sum_01_02 = matrix_01 + matrix_02


'''
Сдвиг матрицы это прибавление постоянного значения к диагонали. Реализуется 
посредством прибавления умноженной на скаляр единичной матрицы:
A + λI.
'''

A = np.array([[0.1, 0.3, 1.2],
              [2.1, 0.2, 1.0],
              [0.7, 2.1, 0.3]])

lamb = 0.2 

I = np.eye(3, k=0)

shift_A = A + lamb*I


'''
Умножение матриц:
Адамово - перемножение соответсвующих элементов матрицы
Стандартное - точечных произведений между строками одной матрицы 
и столбцами другой матрицы
'''

A = np.array([[0.1, 0.3, 1.2],
              [2.1, 0.2, 1.0],
              [0.7, 2.1, 0.3]])

B= np.array([[10, 0.3, 1.2],
              [2.1, 20, 1.0],
              [0.7, 2.1, 30]])

AdamovoAB = A*B

StandartAB = A@B
# Допустимо стандартное перемножение матриц в случае, если количество строк
# первой равно количеству столбцов второй, т.е. допустим у нас есть две матрицы
A = np.array([[0.1, 0.3, 1.2],
              [2.1, 0.2, 1.0]])


B= np.array([[10, 0.3],
              [2.1, 20],
              [0.7, 2.1]])


StandartAB = A@B
StandartBA = B@A


# Транспонирование матрицы

A_transposed = A.transpose()


'''
Ранг – грубо говоря это количество ненулевых строк матрицы
'''
matrix02 = np.random.randn(5, 5)
rank_02 = np.linalg.matrix_rank(matrix02)
rank_A = np.linalg.matrix_rank(A)


'''
Определитель (детерминант) матрицы 
'''

det_02 = np.linalg.det(matrix02)

'''
Обратная матрица
'''

inverse_02 = np.linalg.inv(matrix02)






